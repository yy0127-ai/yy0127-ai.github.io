<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>6.3填充与步幅</title>
    <url>/2023/11/07/6-3%E5%A1%AB%E5%85%85%E4%B8%8E%E6%AD%A5%E5%B9%85/</url>
    <content><![CDATA[<p><strong>影响卷积输出的大小：卷积核的大小、填充和步幅</strong></p>
<h3 id="1-填充"><a href="#1-填充" class="headerlink" title="1.填充"></a>1.填充</h3><blockquote>
<p>在应用多层卷积时，常常丢失边缘像素。由于我们通常使用小卷积核，因此对于任何单个卷积，我们可能只会丢失几个像素。 但随着我们应用许多连续卷积层，累积丢失的像素数就多了。 解决这个问题的简单方法即为<em>填充</em>（padding）：在输入图像的边界填充元素（通常填充元素是0）。</p>
<span id="more"></span>

<p>卷积神经网络中卷积核的高度和宽度通常为奇数，例如1、3、5或7。 选择奇数的好处是，保持空间维度的同时，我们可以在顶部和底部填充相同数量的行，在左侧和右侧填充相同数量的列。</p>
<p>此外，使用奇数的核大小和填充大小也提供了书写上的便利。对于任何二维张量<code>X</code>，当满足： 1. 卷积核的大小是奇数； 2. 所有边的填充行数和列数相同； 3. 输出与输入具有相同高度和宽度 则可以得出：输出<code>Y[i, j]</code>是通过以输入<code>X[i, j]</code>为中心，与卷积核进行互相关计算得到的。</p>
</blockquote>
<p><strong>在下面的例子中，我们创建一个高度和宽度为3的二维卷积层，并在所有侧边填充1个像素。给定高度和宽度为8的输入，则输出的高度和宽度也是8。</strong></p>
<blockquote>
<p>因为padding=1，则8+2=10，输入为10 x 10，K = 3 x 3，则输出为(10-3+1) x (10-3+1) = 8 x 8</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="comment"># 定义一个计算卷积层的函数</span></span><br><span class="line"><span class="comment"># 此函数初始化卷积层权重，并对输入和输出提高和缩减相应的维数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">comp_conv2d</span>(<span class="params">conv2d, X</span>):</span><br><span class="line">    <span class="comment"># 这里的(1, 1)表示批量大小和通道数都为1</span></span><br><span class="line">    X = X.reshape((<span class="number">1</span>, <span class="number">1</span>) + X.shape)  <span class="comment"># X.shape  (1, 1, 8, 8)</span></span><br><span class="line">    Y = conv2d(X)  <span class="comment"># 二维卷积层使用四维输入和输出格式</span></span><br><span class="line">    <span class="comment"># 省略前两个维度：批量大小和通道</span></span><br><span class="line">    <span class="keyword">return</span> Y.reshape(Y.shape[<span class="number">2</span>:])</span><br><span class="line"><span class="comment"># 每边都填充1行或1列，因此总共添加2行或2列</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">X = torch.rand(size=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br><span class="line"><span class="comment"># 结果：torch.Size([8, 8])</span></span><br></pre></td></tr></table></figure>

<p><strong>当卷积核的高度和宽度不同时，我们可以填充不同的高度和宽度，使输出和输入具有相同的高度和宽度。在如下示例中，我们使用高度为5，宽度为3的卷积核，高度和宽度两边的填充分别为2和1</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>,  <span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">3</span>), padding=(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br><span class="line"><span class="comment"># 结果：torch.Size([8, 8])</span></span><br></pre></td></tr></table></figure>

<h3 id="2-步幅"><a href="#2-步幅" class="headerlink" title="2.步幅"></a>2.步幅</h3><blockquote>
<p>在计算互相关时，卷积窗口从输入张量的左上角开始，向下、向右滑动。 在前面的例子中，我们默认每次滑动一个元素。 但是，有时候为了高效计算或是缩减采样次数，卷积窗口可以跳过中间位置，每次滑动多个元素</p>
<p>当垂直步幅为Sh、水平步幅为Sw时，输出形状为：(Nh-Kh+Ph+Sh)/Sh向下取整 + (Nw-Kw+Pw+Sw)/Sw向下取整。</p>
<p>如果我们设置了Pℎ=Kℎ−1和Pw=Kw−1，则输出形状将简化为⌊(Nℎ+Sℎ−1)/Sℎ⌋×⌊(Nw+Sw−1)/Sw⌋。 更进一步，如果输入的高度和宽度可以被垂直和水平步幅整除，则输出形状将为(Nℎ/Sℎ)×(Nw/Sw)。</p>
</blockquote>
<p><strong>将高度和宽度的步幅设置为2，从而将输入的宽度和高度减半</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br><span class="line"><span class="comment"># torch.Size([4, 4])</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂一点的例子</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">3</span>, <span class="number">5</span>), padding=(<span class="number">0</span>, <span class="number">1</span>), stride=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br><span class="line"><span class="comment"># torch.Size([2, 2])</span></span><br></pre></td></tr></table></figure>

<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>填充可以增加输出的高度和宽度。这常用来使输出与输入具有相同的高和宽。</li>
<li>步幅可以减小输出的高和宽，例如输出的高和宽仅为输入的高和宽的1/n（n是一个大于1的整数）。</li>
<li>填充和步幅可用于有效地调整数据的维度。</li>
</ul>
]]></content>
      <categories>
        <category>卷积神经网络</category>
      </categories>
      <tags>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>6.5pooling层</title>
    <url>/2023/11/08/6-5%E6%B1%87%E8%81%9A%E5%B1%82/</url>
    <content><![CDATA[<p><strong>我们的机器学习任务通常会跟全局图像的问题有关（例如，“图像是否包含一只猫呢？”），所以我们最后一层的神经元应该对整个输入的全局敏感。通过逐渐聚合信息，生成越来越粗糙的映射，最终实现学习全局表示的目标，同时将卷积图层的所有优势保留在中间层。</strong></p>
<p><strong>检测较底层的特征时，通常希望这些特征保持某种程度上的平移不变性</strong></p>
<blockquote>
<p>本节将介绍pooling层，它具有双重目的：降低卷积层对位置的敏感性，同时降低对空间降采样表示的敏感性。</p>
</blockquote>
<h3 id="1-最大池化层和平均池化层"><a href="#1-最大池化层和平均池化层" class="headerlink" title="1.最大池化层和平均池化层"></a>1.最大池化层和平均池化层</h3><p><strong>池化层运算符由一个固定形状的窗口组成，该窗口根据其步幅大小在输入的所有区域上滑动，为池化窗口遍历的每个位置计算一个输出。不同于卷积层中的输入与卷积核之间的互相关计算，池化层不包含参数。池运算是确定性的，通常计算池化窗口中所有元素的最大值或平均值。分别为最大池化层和平均池化层</strong></p>
<blockquote>
<p>在下面的pool2d函数实现了池化层的前向传播，这里没有卷积核，输出为输入中每个区域的最大值或平均值。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pool2d</span>(<span class="params">X, pool_size, mode=<span class="string">&#x27;max&#x27;</span></span>):</span><br><span class="line">    p_h, p_w = pool_size</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - p_h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - p_w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="string">&#x27;max&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].<span class="built_in">max</span>()</span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="string">&#x27;avg&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].mean()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br><span class="line"><span class="comment"># 构建输入张量X，验证二维最大池化层的输出</span></span><br><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line">pool2d(X, (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># tensor([[4., 5.],[7., 8.]])</span></span><br><span class="line"><span class="comment"># 验证平均池化层</span></span><br><span class="line">pool2d(X, (<span class="number">2</span>, <span class="number">2</span>), <span class="string">&#x27;avg&#x27;</span>)</span><br><span class="line"><span class="comment">#tensor([[2., 3.], [5., 6.]])</span></span><br></pre></td></tr></table></figure>

<h3 id="2-填充和步幅"><a href="#2-填充和步幅" class="headerlink" title="2.填充和步幅"></a>2.填充和步幅</h3><p><strong>与卷积层一样，池化层也可以改变输出形状，通过填充和步幅以获得所需的输出形状</strong></p>
<blockquote>
<p>使用二维最大池化层，演示填充和步幅，构造了一个输入张量，有四个维度，其中样本数和通道数都为1</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.arange(<span class="number">16</span>, dtype=torch.float32).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment"># 默认情况下，深度学习框架中的步幅与池化窗口的大小相同，如果使用形状为(3, 3)的池化窗口，则步幅形状为(3, 3)</span></span><br><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>)  <span class="comment"># 池化窗口形状为(3, 3) 步幅为(3, 3)</span></span><br><span class="line">pool2d(X)  <span class="comment"># tensor([[[[10.]]]])</span></span><br><span class="line"><span class="comment"># 可以设定任意大小的矩形池化窗口，并分别设定填充和步幅的高度和宽度</span></span><br><span class="line">pool2d = nn.MaxPool2d((<span class="number">2</span>, <span class="number">3</span>), stride=(<span class="number">2</span>, <span class="number">3</span>), padding=(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">pool2d(X)  <span class="comment"># tensor([[[[ 5.,  7.],[13., 15.]]]])</span></span><br></pre></td></tr></table></figure>

<h3 id="3-多个通道"><a href="#3-多个通道" class="headerlink" title="3.多个通道"></a>3.多个通道</h3><p><strong>在处理多通道输入数据时，汇聚层在每个输入通道上单独运算，而不是像卷积层一样在通道上对输入进行汇总。 这意味着汇聚层的输出通道数与输入通道数相同。</strong></p>
<blockquote>
<p>在通道维度上连结张量X和X+1，以构建具有2个通道的输入</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.cat((X, X+<span class="number">1</span>))</span><br><span class="line">X  <span class="comment"># 两个通道 2*4*4</span></span><br><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">pool2d(X) <span class="comment"># 池化后输出通道数量仍是2</span></span><br><span class="line"><span class="comment"># tensor([[[[ 5.,  7.],[13., 15.]]],</span></span><br><span class="line"><span class="comment">#        [[[ 6.,  8.],[14., 16.]]]])</span></span><br></pre></td></tr></table></figure>

<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><ul>
<li>对于给定输入元素，最大池化层会输出该窗口内的最大值，平均池化层会输出该窗口内的平均值。</li>
<li>池化层的主要优点之一是减轻卷积层对位置的过度敏感。</li>
<li>我们可以指定池化层的填充和步幅。</li>
<li>使用最大池化层以及大于1的步幅，可减少空间维度（如高度和宽度）。</li>
<li>池化层的输出通道数与输入通道数相同。</li>
</ul>
]]></content>
      <categories>
        <category>卷积神经网络</category>
      </categories>
      <tags>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>6.4多输入多输出通道</title>
    <url>/2023/11/07/6-4%E5%A4%9A%E8%BE%93%E5%85%A5%E5%A4%9A%E8%BE%93%E5%87%BA%E9%80%9A%E9%81%93/</url>
    <content><![CDATA[<p><strong>多通道，当添加通道时，输入和隐藏的表示都变成三维张量。例如，每个RGB输入图像具有3 x h x w的形状，将这个大小为3的轴称为通道维度</strong></p>
<blockquote>
<p>当通道&gt;1时，卷积核的每个输入通道将包含一个二维张量，由于输入和卷积核都有c个通道，可以对每个通道输入的二维张量和卷积核的二维张量进行互相关运算，再对通道求和得到二维张量。</p>
</blockquote>
<span id="more"></span>

<p><img src="./images/1.png"></p>
<p><strong>实现多输入通道互相关运算，实际上是对每个通道执行互相关运算操作后将结果相加</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="comment"># 先遍历X和K的第0个维度(通道维度)，再把它们加在一起</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(d2l.corr2d(x, k) <span class="keyword">for</span> x, k <span class="keyword">in</span> <span class="built_in">zip</span>(X, K))</span><br><span class="line">X = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]],</span><br><span class="line">               [[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>], [<span class="number">7.0</span>, <span class="number">8.0</span>, <span class="number">9.0</span>]]]) <span class="comment"># 2 * 3 * 3</span></span><br><span class="line">K = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>]], [[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]]]) <span class="comment"># 2 * 2 * 2</span></span><br><span class="line">corr2d_multi_in(X, K)</span><br><span class="line"><span class="comment"># tensor([[ 56.,  72.],</span></span><br><span class="line"><span class="comment">#       [104., 120.]])</span></span><br></pre></td></tr></table></figure>

<h3 id="2-多输出通道"><a href="#2-多输出通道" class="headerlink" title="2.多输出通道"></a>2.多输出通道</h3><p><strong>实现一个计算多个通道的输出的互相关函数</strong></p>
<blockquote>
<p>用Ci和Co分别表示输入和输出通道的数目，并让Kℎ和Kw为卷积核的高度和宽度。为了获得多个通道的输出，我们可以为每个输出通道创建一个形状为Ci×Kℎ×Kw的卷积核张量，这样卷积核的形状是Co×Ci×Cℎ×Cw。在互相关运算中，每个输出通道先获取所有输入通道，再以对应该输出通道的卷积核计算出结果。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in_out</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="comment"># 迭代K的第0个维度，每次都对输入X执行互相关运算</span></span><br><span class="line">    <span class="comment"># 最后将所有结果都叠加在一起</span></span><br><span class="line">    <span class="keyword">return</span> torch.stack([corr2d_multi_in(X, k) <span class="keyword">for</span> k <span class="keyword">in</span> K], <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 通过将核张量K与K+1(K种种每个元素+1) 和K+2连接起来，构造了一个具有3个输出通道的卷积核</span></span><br><span class="line">K = torch.stack((K, K + <span class="number">1</span>, K + <span class="number">2</span>), <span class="number">0</span>)</span><br><span class="line">K.shape  <span class="comment"># 3*2*2*2</span></span><br><span class="line"><span class="comment"># 下面，我们对输入张量X与卷积核张量K执行互相关运算。现在的输出包含</span></span><br><span class="line"><span class="comment"># 个通道，第一个通道的结果与先前输入张量X和多输入单输出通道的结果一致</span></span><br><span class="line">corr2d_multi_in_out(X, K)</span><br><span class="line"><span class="comment"># 结果：tensor([[[ 56.,  72.],</span></span><br><span class="line"><span class="comment">#        [104., 120.]],</span></span><br><span class="line"><span class="comment">#       [[ 76., 100.],</span></span><br><span class="line"><span class="comment">#        [148., 172.]],</span></span><br><span class="line"><span class="comment">#        [[ 96., 128.],</span></span><br><span class="line"><span class="comment">#        [192., 224.]]])</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-1卷积层"><a href="#3-1-1卷积层" class="headerlink" title="3.   1 * 1卷积层"></a>3.   1 * 1卷积层</h3><blockquote>
<p>使用1×1卷积核与3个输入通道和2个输出通道的互相关计算。 这里输入和输出具有相同的高度和宽度，输出中的每个元素都是从输入图像中同一位置的元素的线性组合。 我们可以将1×1卷积层看作在每个像素位置应用的全连接层，以Ci个输入值转换为Co个输出值。 因为这仍然是一个卷积层，所以跨像素的权重是一致的。 同时，1×1卷积层需要的权重维度为Co×Ci，再额外加上一个偏置。</p>
</blockquote>
<p><img src="../images/2.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用全连接层实现1 * 1卷积，需要对输入和输出的数据形状进行调整</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in_out_1x1</span>(<span class="params">X, K</span>):</span><br><span class="line">    c_i, h, w = X.shape  <span class="comment"># 输入通道数 高度 宽度</span></span><br><span class="line">    c_o = K.shape[<span class="number">0</span>] <span class="comment"># 输出通道数</span></span><br><span class="line">    X = X.reshape((c_i, h * w))</span><br><span class="line">    K = K.reshape((c_o, c_i))</span><br><span class="line">    <span class="comment"># 全连接中的矩阵乘法</span></span><br><span class="line">    Y = torch.matmul(K, X)</span><br><span class="line">    <span class="keyword">return</span> Y.reshape((c_o, h, w))</span><br><span class="line">X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">K = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">Y1 = corr2d_multi_in_out_1x1(X, K)</span><br><span class="line">Y2 = corr2d_multi_in_out(X, K)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">float</span>(torch.<span class="built_in">abs</span>(Y1 - Y2).<span class="built_in">sum</span>()) &lt; <span class="number">1e-6</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>卷积神经网络</category>
      </categories>
      <tags>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>6.6卷积神经网络(LeNet)</title>
    <url>/2023/11/08/6-6%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-LeNet/</url>
    <content><![CDATA[<p><strong>为了能够应用softmax回归和多层感知机，我们首先将每个大小为28×28的图像展平为一个784维的固定长度的一维向量，然后用全连接层对其进行处理。而现在，我们已经掌握了卷积层的处理方法，我们可以在图像中保留空间结构。 同时，用卷积层代替全连接层的另一个好处是：模型更简洁、所需的参数更少。</strong></p>
<h3 id="1-LeNet"><a href="#1-LeNet" class="headerlink" title="1. LeNet"></a>1. LeNet</h3><p>LeNet由两个部分组成：</p>
<ul>
<li>卷积编码器：由两个卷积层组成</li>
<li>全连接层密集块：由三个全连接层组成</li>
</ul>
<p><img src="../images/3.png"></p>
<span id="more"></span>

<blockquote>
<p>通过下面的LeNet代码，可以看出用深度学习框架实现此类模型非常简单。我们只需要实例化一个<code>Sequential</code>块并将需要的层连接在一起。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>), nn.Sigmoid(), <span class="comment"># 输入通道为1，输出通道为6  6*28*28</span></span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),  <span class="comment"># 6 *14*14</span></span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), nn.Sigmoid(), <span class="comment"># 输入通道为6，输出通道为1  16  *10*10</span></span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>), <span class="comment"># 16 *5*5</span></span><br><span class="line">    nn.Flatten(),<span class="comment"># 16*25*25</span></span><br><span class="line">    nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 通过在每一层打印输出的形状，我们可以检查模型是否一致</span></span><br><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>), dtype=torch.float32)  <span class="comment"># 一个样本一个通道</span></span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__,<span class="string">&#x27;output shape: \t&#x27;</span>, X.shape)</span><br><span class="line"><span class="comment">#Conv2d output shape: 	 torch.Size([1, 6, 28, 28])</span></span><br><span class="line"><span class="comment">#Sigmoid output shape: 	 torch.Size([1, 6, 28, 28])</span></span><br><span class="line"><span class="comment">#AvgPool2d output shape: 	 torch.Size([1, 6, 14, 14])</span></span><br><span class="line"><span class="comment">#Conv2d output shape: 	 torch.Size([1, 16, 10, 10])</span></span><br><span class="line"><span class="comment">#Sigmoid output shape: 	 torch.Size([1, 16, 10, 10])</span></span><br><span class="line"><span class="comment">#AvgPool2d output shape: 	 torch.Size([1, 16, 5, 5])</span></span><br><span class="line"><span class="comment">#Flatten output shape: 	 torch.Size([1, 400])</span></span><br><span class="line"><span class="comment">#Linear output shape: 	 torch.Size([1, 120])</span></span><br><span class="line"><span class="comment">#Sigmoid output shape: 	 torch.Size([1, 120])</span></span><br><span class="line"><span class="comment">#Linear output shape: 	 torch.Size([1, 84])</span></span><br><span class="line"><span class="comment">#Sigmoid output shape: 	 torch.Size([1, 84])</span></span><br><span class="line"><span class="comment">#Linear output shape: 	 torch.Size([1, 10])</span></span><br></pre></td></tr></table></figure>

<h3 id="2-模型训练"><a href="#2-模型训练" class="headerlink" title="2.模型训练"></a>2.模型训练</h3><p><strong>已经实现了LeNet，看看其在Fashion-MNIST数据集上的表现</strong></p>
]]></content>
      <categories>
        <category>卷积神经网络</category>
      </categories>
      <tags>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-2</title>
    <url>/2023/11/12/leetcode%E5%88%B7%E9%A2%98-%E9%A2%98%E8%A7%A3-2/</url>
    <content><![CDATA[<h3 id="451-根据字符出现频率排序"><a href="#451-根据字符出现频率排序" class="headerlink" title="451.根据字符出现频率排序"></a>451.根据字符出现频率排序</h3><p><strong>描述：给定一个字符串 s ，根据字符出现的 频率 对其进行 降序排序 。一个字符出现的 频率 是它出现在字符串中的次数。返回 已排序的字符串 。如果有多个答案，返回其中任何一个。</strong></p>
<blockquote>
<p>示例1:<br>输入: s = “tree”<br>输出: “eert”<br>解释: ‘e’出现两次，’r’和’t’都只出现一次。<br>因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。</p>
</blockquote>
<p><strong>解法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">frequencySort</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//将字符以及对应的频次存放在map集合中，然后根据频次进行排序，最后将排序完的遍历输出</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Character&gt;(map.keySet());<span class="comment">//创建list集合存储map中的key</span></span><br><span class="line">        Collections.sort(list, (a, b) -&gt; map.get(b) - map.get(a)); <span class="comment">//按照频次的降序排列list</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; map.get(c1); j++)&#123;</span><br><span class="line">                sb.append(c1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度：O(n + klogk)，其中n为字符串s的长度，k是字符串s包含的不同字符的个数。遍历每个字符串统计每个字符出现的频率需要O(n)，将字符按照出现的频次排序需要O(klogk)的时间。生成排序后的字符串，需要遍历k个不同字符，需要O(k)的时间，拼接字符串需要O(n)的时间。</strong></p>
<hr>
<p><strong>解法二：桶排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">frequencySort</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//使用桶排序，让每个频次呆在一个桶中</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxFreq</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用来存放最大的频次，也就是桶要多少个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> map.getOrDefault(s.charAt(i), <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            map.put(s.charAt(i), frequency);</span><br><span class="line">            maxFreq = Math.max(maxFreq, frequency);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer[] buckets = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>[maxFreq + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= maxFreq; i++)&#123;</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character, Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            buckets[frequency].append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> maxFreq; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; buckets[i].length(); j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; i; k++)&#123;</span><br><span class="line">                    sb.append(buckets[i].charAt(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度：O(n + k)，遍历字符串统计每个字符出现的频率需要O(n)的时间。创建桶并将不同字符加入桶需要O(k)的时间。生成排序后的字符串，需要O(k)的时间遍历桶，以及O(n)的拼接字符串时间</strong></p>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题-题解</title>
    <url>/2023/11/09/leetcode%E5%88%B7%E9%A2%98-%E9%A2%98%E8%A7%A3-1/</url>
    <content><![CDATA[<h3 id="347-前K个高频元素"><a href="#347-前K个高频元素" class="headerlink" title="347.前K个高频元素"></a>347.前K个高频元素</h3><p><strong>描述：给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</strong></p>
<blockquote>
<p>示例1：<br>输入： nums = [1, 1, 1, 2, 2, 3] ,k = 2</p>
</blockquote>
<p><strong>思考：为什么会用堆和二叉搜索树呢？</strong></p>
<blockquote>
<p>问题：查找topk<br>1）大根堆：堆顶元素最大，取k个堆顶元素即可<br>2）小根堆：维护只有k个节点的小根堆，每次加入节点时，判断是否大于小根堆的堆顶，大于则删除堆顶，将新节点加入，最后将堆里的k个元素遍历出来即可<br>3）二叉搜索树：排好序了，左节点&lt;父节点&lt;右节点(对于一个节点来说)，可以取到树的最小值，跟新节点判断，若频次大，则删除最小值，加入频次大的值，此时要判断每个频次对应的数值size，size为1时直接删除该节点，size值大于1的话，删除list中的最后一个元素，因为此二叉树维护的是包含k个数据，而不是包含k个节点，也就是说相同频次对应的不同值存放在一个list中</p>
</blockquote>
<span id="more"></span>

<p><strong>解法一：大根堆</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">// 定义一个Map集合，用于存放key为nums的每一个数值，value为每一个数值出现的频次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums)&#123;</span><br><span class="line">					<span class="comment">// getOrDefault()方法：若是有值返回n对应的value，无值返回0</span></span><br><span class="line">            map.put(n, map.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);  <span class="comment">// key为数组中的值n，value为频次</span></span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1, e2) -&gt; e2.getValue() - e1.getValue());  <span class="comment">// 比较器,优先级队列 若e1.getValue()大则返回负数</span></span><br><span class="line">        queue.addAll(map.entrySet());  <span class="comment">// 大根堆 </span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k &amp;&amp; !queue.isEmpty(); ++i)&#123;</span><br><span class="line">            ans[i] = queue.poll().getKey();  <span class="comment">//删除堆顶，堆尾元素补上并且进行大根堆调整</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二：小根堆</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//小根堆</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; counter = IntStream.of(nums).boxed().collect(Collectors.toMap(e -&gt; e, e -&gt; <span class="number">1</span>, Integer::sum));  <span class="comment">//Collector.toMap(function&lt;&gt; keyMapper, Function&lt;&gt; valueMapper, BinaryOpertor&lt;&gt; mergeFunction)  # 第一个函数将key映射为k，第二个函数将值映射为1(初始频次)，第三个函数，当出现两个对象key重复时，则会对这两个对象的value进行sum求和</span></span><br><span class="line">        <span class="comment">//则counter为Map集合，key为nums中的每个不重复的值，value为每个值出现频次</span></span><br><span class="line">        <span class="comment">//定义小根堆，根据数字频率自小到大排序</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((k1, k2) -&gt; counter.get(k1)-counter.get(k2));</span><br><span class="line">        <span class="comment">//遍历数组，维护一个大小为k的小根堆</span></span><br><span class="line">        <span class="comment">//不足k个直接将当前数字加入到堆中，否则判断堆中的最小次数是否小于当前数字的出现次数，若是，则删掉堆中出现次数最少的一个数字，将当前数字加入堆中</span></span><br><span class="line">        <span class="comment">//想法就是，堆的大小为k，然后想让堆中存在k个大频次，所以当存满k个对象时，就判断新的对象的频次是否大于小根堆堆顶(最小的频次)，大于则删掉堆顶，将新的对象加入，内部会进行堆调整</span></span><br><span class="line">        counter.forEach((num, fre) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.size() &lt; k)&#123;</span><br><span class="line">                queue.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(counter.get(queue.peek()) &lt; fre)&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//构造返回结果，从堆中将数据读取出来</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: queue)&#123;</span><br><span class="line">            res[i++] = num; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法三：二叉搜索树</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//二叉搜索树</span></span><br><span class="line">        <span class="comment">//统计每个数字出现的次数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = IntStream.of(nums).boxed().collect(Collectors.toMap(e-&gt;e, e-&gt;<span class="number">1</span>, Integer::sum));</span><br><span class="line">        <span class="comment">//定义二叉搜索树：key是数字出现的次数，value是出现了key次的数字列表</span></span><br><span class="line">        TreeMap&lt;Integer, List&lt;Integer&gt;&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//维护一个有k个数字的二叉搜索树,左子树都比父节点小，右子树都比父节点大</span></span><br><span class="line">        <span class="comment">//不足k个直接将当前数字加入到树中，否则判断当前树中的最小次数是否小于当前出现数字的次数</span></span><br><span class="line">        <span class="comment">//若是，则删掉树中出现次数最少的一个数字，将当前数字加入树中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">fre</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(count &lt; k)&#123;</span><br><span class="line">                treeMap.computeIfAbsent(fre, ArrayList::<span class="keyword">new</span>).add(num);  <span class="comment">//指定的键未与值相连，则new一个ArrayList，将num添加到数组中，若相连则直接将num添加到数组中</span></span><br><span class="line">                count++;  <span class="comment">//计数的是list中的总元素个数，而不是节点个数</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//此时count&gt;=k</span></span><br><span class="line">                <span class="comment">//取出第一个节点</span></span><br><span class="line">                Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; firstEntry = treeMap.firstEntry();<span class="comment">//返回key最小的map映射</span></span><br><span class="line">                <span class="keyword">if</span>(fre &gt; firstEntry.getKey())&#123;<span class="comment">//当前对象的key频次大于treeMap中存在的最小频次，则将其添加到treMap中，并且删掉最小的频次</span></span><br><span class="line">                    treeMap.computeIfAbsent(fre, ArrayList::<span class="keyword">new</span>).add(num);</span><br><span class="line">                    List&lt;Integer&gt; list = firstEntry.getValue();<span class="comment">//出现频次对应的值</span></span><br><span class="line">                    <span class="keyword">if</span>(list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">//list中只有一个元素，也就是只有一个元素出现了该频次，则直接删除</span></span><br><span class="line">                        treeMap.pollFirstEntry();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        list.remove(list.size() - <span class="number">1</span>);<span class="comment">//此时存在&gt;1的list，则直接将该list的最后一个值删掉</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回构造结果</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; list: treeMap.values())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num : list)&#123;</span><br><span class="line">                res[idx++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四种方法：计数排序(桶排序)</strong><br><strong>算法思想：用一个数组来存储每个频次的数值，频次为数组的下标，数值所组成的数组为数组的每个下标对应的值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//计数排序(桶排序)</span></span><br><span class="line">        <span class="comment">//统计每个数字出现的次数 [1, 2, 1, 3, 4, 1, 2]</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = IntStream.of(nums).boxed().collect(Collectors.toMap(e-&gt;e, e-&gt;<span class="number">1</span>, Integer::sum));  <span class="comment">//&#123;1:3, 2:2, 3:1, 4:1&#125;</span></span><br><span class="line">        <span class="comment">//一个数字最多出现nums.length次，因此定义一个长度为nums.length+1的数组，freqList[i]表示存储出现次为i的所有数字</span></span><br><span class="line">        <span class="comment">//用一个list来存放出现i频次的数值，也就是每个位置都存放一个数字，而位置是由频次决定的</span></span><br><span class="line">        List&lt;Integer&gt;[] freqList = <span class="keyword">new</span> <span class="title class_">List</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; freqList.length; i++)&#123;</span><br><span class="line">            freqList[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        map.forEach((num, freq)-&gt;&#123;</span><br><span class="line">            freqList[freq].add(num);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//按照出现频次，从大到小遍历频次数组，构造返回结果</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> freqList.length-<span class="number">1</span>; freq &gt; <span class="number">0</span>; freq--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num: freqList[freq])&#123;</span><br><span class="line">                res[idx++] = num;</span><br><span class="line">                <span class="keyword">if</span>(idx == k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法五：快速排序的变形方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//快排变形</span></span><br><span class="line">        <span class="comment">//统计每个数字出现的次数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = IntStream.of(nums).boxed().collect(Collectors.toMap(</span><br><span class="line">            e-&gt;e, e-&gt;<span class="number">1</span>, Integer::sum</span><br><span class="line">        ));</span><br><span class="line">        <span class="comment">//构造Pair数组，Pair.num表示数值，Pair.freq表示数字出现的次数</span></span><br><span class="line">        Pair[] pairs = IntStream.of(nums).distinct().boxed().map(num -&gt; <span class="keyword">new</span> <span class="title class_">Pair</span>(num, map.get(num))).toArray(Pair[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="comment">//使用快速变形 获取Pair数组中频次最大的k个元素(第4个参数是下标，因此是K-1)</span></span><br><span class="line">        Pair[] topKPairs = quickSelect(pairs, <span class="number">0</span>, pairs.length-<span class="number">1</span>, k-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//构造返回结果</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Pair pair: topKPairs)&#123;</span><br><span class="line">            res[idx++] = pair.num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Pair[] quickSelect(Pair[] pairs, <span class="type">int</span> lo, <span class="type">int</span> hi, <span class="type">int</span> idx)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt; hi)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//快排切分后，j左边的数字出现的次数都大于等于pairs[j].freq, j右边出现的次数都小于等于pair[j].freq</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(pairs, lo, hi);</span><br><span class="line">        <span class="comment">//如果j正好等于目标idx，说明当前数组中的[0, idx]就是出现次数最大的K个元素</span></span><br><span class="line">        <span class="keyword">if</span>(j == idx) &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(pairs, idx+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则根据j与idx的大小关系判断找左端还是右端</span></span><br><span class="line">        <span class="keyword">return</span> j &lt; idx ? quickSelect(pairs, j+<span class="number">1</span>, hi, idx) : quickSelect(pairs, lo, j-<span class="number">1</span>, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Pair[] pairs, <span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="type">Pair</span> <span class="variable">v</span> <span class="operator">=</span> pairs[lo];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(++i &lt;= hi &amp;&amp; pairs[i].freq &gt; v.freq);</span><br><span class="line">            <span class="keyword">while</span>(--j &gt;= lo &amp;&amp; pairs[j].freq &lt; v.freq);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Pair</span> <span class="variable">tmp</span> <span class="operator">=</span> pairs[i];</span><br><span class="line">            pairs[i] = pairs[j];</span><br><span class="line">            pairs[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        pairs[lo] = pairs[j];</span><br><span class="line">        pairs[j] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> freq;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> freq)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.freq = freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>将数值，以及数值出现的频次存在map键值对中的方法：</li>
<li><pre><code class="java">  Map&lt;Integer, Integer&gt; map = IntStream.of(nums).boxed().collect(Collectors.toMap(e-&gt;e, e-&gt;1, Integer::sum)); //第一种    
  //第二种
  Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
  for(int num: nums)&#123;
      map.put(num, map.getOrDefault(num, 0)+1)
   &#125;
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题-题解-3</title>
    <url>/2023/11/12/leetcode%E5%88%B7%E9%A2%98-%E9%A2%98%E8%A7%A3-3/</url>
    <content><![CDATA[<h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75.颜色分类"></a>75.颜色分类</h3><p><strong>描述：给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>必须在不使用库内置的 sort 函数的情况下解决这个问题</strong></p>
<blockquote>
<p>示例1：<br>输入：nums = [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]</p>
</blockquote>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] colorNums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            colorNums[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> colorNums[i];</span><br><span class="line">            <span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[j++] = i;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<blockquote>
<p>题目本质是要分三段<br>因此除了使用一个变量idx代指处理到哪一个nums[i]之外，至少还需要两个变量来代指三段的边界：<br>变量l为下一个填入0的位置(所以范围[0, l-1]均为0，初始化l=0，代表空集)<br>变量r为下一个填入2的位置（所以范围[r+1, n-1]都是2，初始r=n-，代表空集）<br>由于[0, idx-1]均为处理过的数值(也就意味着0和2被分到了两端)，同时l-1又是0的右边界，因此[l, idx-1]为1的区间，而[idx, r]为未处理的数值。<br>上述几个变量的定义是该题唯一需要弄清楚的地方<br>不失一般性，根据当前处理到的nums[idx]进行分情况讨论<br>nums[idx]=0:此时将其与位置l进行交换(因为l为下一个待填入0的位置，同时[l,idx-1]为1的区间)，本质将nums[idx]的0和nums[l]的1进行交换，因此互换后将l和idx进行右移；<br>nums[idx]=1时，由于[l, idx-1]本身就是1的区间，直接将idx进行右移即可<br>nums[idx]=2时：此时将其位置r进行互换(r为下一个待填入2的位置，但[idx, r]为未处理区间）也就是我们互换后，只能明确换到位置nums[r]的位置为2，可以对r进行左移，但不确定新的nums[idx]为何值，所以idx不变再入循环判断<br>当idx&gt;r，整个分段过程结束</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>, idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[idx] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, l++, idx++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[idx] == <span class="number">1</span>)&#123;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                swap(nums, idx, r--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>leetcode刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题-题解</title>
    <url>/2023/11/13/leetcode%E5%88%B7%E9%A2%98-%E9%A2%98%E8%A7%A3-4/</url>
    <content><![CDATA[<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h3><p><strong>描述：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</strong></p>
<blockquote>
<p>示例：<br>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4</p>
</blockquote>
<p><strong>解法一：二分查找</strong></p>
<blockquote>
<p>在升序数组中寻找目标值target，比较当前值nums[i]与目标值target之间的大小<br>如果nums[i] = target, 则下标i即为要找的下标<br>如果nums[i] &gt; target,则target只能在i的左侧<br>如果nums[i] &lt; target,则target只能在i的右侧<br>二分查找：定义的查找范围为[left, right],每次查找比较nums[mid]与target的大小，每次查找都会将查找范围缩小一半，所以二分查找的时间复杂度是O(logn)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (high - low)/<span class="number">2</span> + low; <span class="comment">//加上low表示当前mid下标</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">**时间复杂度：O(logn)。空间复杂度：O(<span class="number">1</span>).**</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>leetcode刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题-题解-5</title>
    <url>/2023/11/13/leetcode%E5%88%B7%E9%A2%98-%E9%A2%98%E8%A7%A3-5/</url>
    <content><![CDATA[<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h3><p><strong>描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</strong></p>
<blockquote>
<p>示例：<br>输入：nums = [3,2,2,3], val = 3<br>输出：2, nums = [2,2]</p>
</blockquote>
<p><strong>解法一：双指针</strong><br><strong>解析：左右指针均从0开始，右指针指向当前要处理的元素，左指针指向下一个要赋值的位置，如果当前值不等于val，它一定为输出数组中的一个元素，将当前元素赋值给左指针，左右指针同时右移。如果当前值等于val，则它不是输出数组中的值，则左指针不动，右指针右移</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//移除数组中的指定元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] == val)&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[left++] = nums[right];</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度：O(n).空间复杂度O(1)</strong></p>
<hr>
<p><strong>解法二：双指针解法</strong></p>
<blockquote>
<p>将数组分成前后两段<br>前半段是有效部分，存储的是不等于val的元素<br>后半段是无效部分，存储的是等于val的元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//移除数组中的指定元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left;</span><br><span class="line">        <span class="keyword">for</span>(left = <span class="number">0</span>; left &lt;= right; left++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == val)&#123;</span><br><span class="line">                <span class="comment">//等于，则将其放入第二段，也就是与右指针交换</span></span><br><span class="line">                swap(nums, left, right);</span><br><span class="line">                left--;<span class="comment">//由于交换完了，并不知道交换到第一段的元素值是否为val，所以--，重新判断一遍</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度：O(n).空间复杂度O(1)</strong></p>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>leetcode刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>myfirst_blog</title>
    <url>/2023/11/06/myfirst-blog/</url>
    <content><![CDATA[<h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h3><h3 id="2-安装nodejs"><a href="#2-安装nodejs" class="headerlink" title="2.安装nodejs"></a>2.安装nodejs</h3><span id="more"></span>

<h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h3><h3 id="4-编写博客"><a href="#4-编写博客" class="headerlink" title="4.编写博客"></a>4.编写博客</h3><ol>
<li><p>新建文章</p>
<ol>
<li>```<br>hexo new newpapername<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 在source/_post中打开markdown文档，开始编辑，写完保存，使用下面命令</span><br><span class="line"></span><br><span class="line">   1. ```</span><br><span class="line">      hexo clean</span><br><span class="line">      hexo g</span><br><span class="line">      hexo d  # 部署</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>新手</tag>
        <tag>start</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题---题解</title>
    <url>/2023/11/07/leetcode%E5%88%B7%E9%A2%98-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Leetcode题解-排序"><a href="#Leetcode题解-排序" class="headerlink" title="Leetcode题解-排序"></a>Leetcode题解-排序</h3><h4 id="215-数组中的第k个最大元素"><a href="#215-数组中的第k个最大元素" class="headerlink" title="215.数组中的第k个最大元素"></a>215.数组中的第k个最大元素</h4><blockquote>
<p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。<br>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
</blockquote>
<span id="more"></span>

<p><strong>示例1：</strong></p>
<blockquote>
<p>输入：[3, 2, 1, 5, 6,4] ，k=2<br>输出: 5</p>
</blockquote>
<p><strong>自己想法：首先排序，最后取出第k大的元素(然后发现自己不会写快排)</strong><br><strong>解法一：暴力解法</strong></p>
<blockquote>
<p>分析一下：找到第k个最大的元素，而不是第k个不同元素，意味着升序排完序后，从数组右侧数的第k个元素，则从左边数为len-k</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//暴力解法  用数组的排序方法进行求解</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[len - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(NlogN)，JDK默认使用快速排序；</li>
<li>空间复杂度：O(logN)，空间复杂度递归调用栈的高度；</li>
</ul>
<p><strong>解法二：减而治之—-快速选择算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//快速排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> len - k;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span>(target == pivotIndex)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pivotIndex &gt; target)&#123;</span><br><span class="line">                right = pivotIndex - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = pivotIndex + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//进行排序、交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> left + random.nextInt(right-left + <span class="number">1</span>);</span><br><span class="line">        swap(nums, left, randomIndex);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left]; <span class="comment">//取一个基值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">le</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(le &lt;= ge &amp;&amp; nums[le] &lt; pivot)&#123;  <span class="comment">//发现里面的判断条件是有先后关系的，最先跳出while的是le&lt;=ge如果不满足这个条件不可能nums[le] &lt; pivot</span></span><br><span class="line">                le++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(le &lt;= ge &amp;&amp; nums[ge] &gt; pivot)&#123;</span><br><span class="line">                ge--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(le &gt;= ge)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, le, ge);</span><br><span class="line">            le++;</span><br><span class="line">            ge--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, ge);</span><br><span class="line">        <span class="keyword">return</span> ge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)  (没有使用递归)</li>
<li><em>解法三：优先队列</em>*<blockquote>
<p>找到第K大元素，也就是整个数组排序后后半部分最小的那个元素。所以可以用k个元素的最小堆</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">       PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();   <span class="comment">//定义一个优先队列</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;  <span class="comment">//队列中只存k个元素，对顶就是k个元素中最小的那个，也就是第k大的元素</span></span><br><span class="line">           heap.add(num);  <span class="comment">//内部：新插入的元素 与其父节点进行比较，然后调整堆</span></span><br><span class="line">           <span class="keyword">if</span>(heap.size() &gt; k)&#123;  <span class="comment">//元素个数超过k</span></span><br><span class="line">               heap.poll();  <span class="comment">//移除头部元素 最后一个元素被移动到堆顶，在进行堆调整</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> heap.peek();  <span class="comment">//返回堆顶元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>6.2卷积神经网络—图像卷积</title>
    <url>/2023/11/07/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E5%9B%BE%E5%83%8F%E5%8D%B7%E7%A7%AF/</url>
    <content><![CDATA[<h3 id="1-互相关运算"><a href="#1-互相关运算" class="headerlink" title="1.互相关运算"></a>1.互相关运算</h3><h4 id="1-1在corr2d函数中实现卷积过程"><a href="#1-1在corr2d函数中实现卷积过程" class="headerlink" title="1.1在corr2d函数中实现卷积过程"></a>1.1在corr2d函数中实现卷积过程</h4><p><strong>该函数接受输入张量X和卷积核张量K，并返回输出张量Y</strong></p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d</span>(<span class="params">X, K</span>): <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算二维互相关运算&quot;&quot;&quot;</span></span><br><span class="line">    h, w = K.shape  <span class="comment"># 卷积核的高 宽</span></span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - w + <span class="number">1</span>))  <span class="comment"># 初始化Y</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            Y[i, j] = (X[i:i+h, j:j+w] * K).<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure>

<p><strong>输入张量X和卷积核张量K，验证上述二维互相关运算的输入</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line">K = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>]])</span><br><span class="line">corr2d(X, K)</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([[19., 25.],</span><br><span class="line">        [37., 43.]])</span><br></pre></td></tr></table></figure>

<h3 id="2-卷积层"><a href="#2-卷积层" class="headerlink" title="2.卷积层"></a>2.卷积层</h3><p><strong>卷积层对输入和卷积核权重进行互相关运算，并在添加标量偏置之后产生输出。因此卷积层中两个被训练的参数为卷积核权重和标量偏置</strong></p>
<p><strong>基于上面定义的corr2d函数实现二维卷积层。在__init__构造函数中，将<code>weight</code>和<code>bias</code>声明为两个模型参数，前向传播函数调用<code>corr2d</code>函数并添加偏置</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 卷积层</span></span><br><span class="line"><span class="comment"># 随机初始化权重</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Conv2D</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kernel_size</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.weight = nn.Parameter(torch.rand(kernel_size))</span><br><span class="line">        self.bias = nn.Parameter(torch.zeros(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> corr2d(x, self.weight) + bias</span><br></pre></td></tr></table></figure>

<p><strong>使用上述函数：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = Conv2D((<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">x = torch.tensor([[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>],</span><br><span class="line">                   [<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>],</span><br><span class="line">                   [<span class="number">9.0</span>, <span class="number">10.0</span>, <span class="number">11.0</span>, <span class="number">12.0</span>],</span><br><span class="line">                   [<span class="number">13.0</span>, <span class="number">14.0</span>, <span class="number">15.0</span>, <span class="number">16.0</span>]], dtype=torch.float32)</span><br><span class="line">output = net(x)</span><br><span class="line">output</span><br></pre></td></tr></table></figure>

<p><strong>结果为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([[11.7987, 14.6210, 17.4432],</span><br><span class="line">        [23.0878, 25.9100, 28.7323],</span><br><span class="line">        [34.3768, 37.1990, 40.0213]], grad_fn=&lt;AddBackward0&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="3-图像中目标的边缘检测"><a href="#3-图像中目标的边缘检测" class="headerlink" title="3.图像中目标的边缘检测"></a>3.图像中目标的边缘检测</h3><p><strong>通过找到像素变化的位置，来检测图像中不同颜色的边缘。 首先，我们构造一个6×8像素的黑白图像。中间四列为黑色（0），其余像素为白色（1）。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.ones((<span class="number">6</span>,<span class="number">8</span>))</span><br><span class="line">X[:, <span class="number">2</span>:<span class="number">6</span>] = <span class="number">0</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([[1., 1., 0., 0., 0., 0., 1., 1.],</span><br><span class="line">        [1., 1., 0., 0., 0., 0., 1., 1.],</span><br><span class="line">        [1., 1., 0., 0., 0., 0., 1., 1.],</span><br><span class="line">        [1., 1., 0., 0., 0., 0., 1., 1.],</span><br><span class="line">        [1., 1., 0., 0., 0., 0., 1., 1.],</span><br><span class="line">        [1., 1., 0., 0., 0., 0., 1., 1.]])</span><br></pre></td></tr></table></figure>

<p><strong>接下来，我们构造一个高度为1、宽度为2的卷积核<code>K</code>。当进行互相关运算时，如果水平相邻的两元素相同，则输出为零，否则输出为非零。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">K = torch.tensor([[<span class="number">1.0</span>, -<span class="number">1.0</span>]])</span><br></pre></td></tr></table></figure>

<p><strong>现在，我们对参数<code>X</code>（输入）和<code>K</code>（卷积核）执行互相关运算。 如下所示，输出<code>Y</code>中的1代表从白色到黑色的边缘，-1代表从黑色到白色的边缘，其他情况的输出为0。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Y = corr2d(X, K)</span><br><span class="line">Y</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([[ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span><br><span class="line">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span><br><span class="line">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span><br><span class="line">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span><br><span class="line">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span><br><span class="line">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.]])</span><br></pre></td></tr></table></figure>

<p><strong>现在我们将输入的二维图像转置，再进行如上的互相关运算。 其输出如下，之前检测到的垂直边缘消失了。 不出所料，这个卷积核<code>K</code>只可以检测垂直边缘，无法检测水平边缘。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr2d(X.t(), K)</span><br><span class="line"><span class="comment">#tensor([[0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="comment">#       [0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="comment">#       [0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="comment">#       [0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="comment">#       [0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="comment">#       [0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="comment">#       [0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="comment">#       [0., 0., 0., 0., 0.]])</span></span><br></pre></td></tr></table></figure>

<h3 id="4-学习卷积核"><a href="#4-学习卷积核" class="headerlink" title="4.学习卷积核"></a>4.学习卷积核</h3><p><strong>如果我们只需寻找黑白边缘，那么以上<code>[1, -1]</code>的边缘检测器足以。然而，当有了更复杂数值的卷积核，或者连续的卷积层时，我们不可能手动设计滤波器。那么我们是否可以学习由<code>X</code>生成<code>Y</code>的卷积核呢？</strong></p>
<p><strong>现在让我们看看是否可以通过仅查看“输入-输出”对来学习由<code>X</code>生成<code>Y</code>的卷积核。 我们先构造一个卷积层，并将其卷积核初始化为随机张量。接下来，在每次迭代中，我们比较<code>Y</code>与卷积层输出的平方误差，然后计算梯度来更新卷积核。为了简单起见，我们在此使用内置的二维卷积层，并忽略偏置。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 学习卷积核</span></span><br><span class="line"><span class="comment"># 构造一个二维卷积层，具有1个输出通道和形状为(1, 2)的卷积核</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">1</span>, <span class="number">2</span>), bias=<span class="literal">False</span>) <span class="comment"># 1 1 表示输入通道、输出通道</span></span><br><span class="line"><span class="comment"># 这个二维卷积层使用四维输入和输出格式（批量大小、通道、高度、宽度）</span></span><br><span class="line"><span class="comment"># 其中批量大小和通道数都为1</span></span><br><span class="line">X = X.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">Y = Y.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line">lr = <span class="number">3e-2</span> <span class="comment"># 学习率</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    Y_hat = conv2d(X)</span><br><span class="line">    l = (Y_hat - Y) ** <span class="number">2</span> <span class="comment"># 计算损失</span></span><br><span class="line">    conv2d.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">    l.<span class="built_in">sum</span>().backward()  <span class="comment"># 向后传播</span></span><br><span class="line">    <span class="comment"># 迭代卷积</span></span><br><span class="line">    conv2d.weight.data[:] -= lr * conv2d.weight.grad  <span class="comment"># 更新梯度</span></span><br><span class="line">    <span class="keyword">if</span>(i + <span class="number">1</span>) %<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l.<span class="built_in">sum</span>():<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>结果为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">epoch 2, loss 2.360</span><br><span class="line">epoch 4, loss 0.514</span><br><span class="line">epoch 6, loss 0.134</span><br><span class="line">epoch 8, loss 0.042</span><br><span class="line">epoch 10, loss 0.015</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d.weight.data.reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># tensor([[ 0.9590, -1.0091]]) 卷积核权重的结果很接近之前定义的卷积核K</span></span><br></pre></td></tr></table></figure>

<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h3><ul>
<li>二维卷积层的核心计算是二维互相关运算。最简单的形式是，对二维输入数据和卷积核执行互相关操作，然后添加一个偏置。</li>
<li>我们可以设计一个卷积核来检测图像的边缘。</li>
<li>我们可以从数据中学习卷积核的参数。</li>
<li>学习卷积核时，无论用严格卷积运算或互相关运算，卷积层的输出不会受太大影响。</li>
<li>当需要检测输入特征中更广区域时，我们可以构建一个更深的卷积网络。</li>
</ul>
]]></content>
      <categories>
        <category>卷积神经网络</category>
      </categories>
      <tags>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
</search>
